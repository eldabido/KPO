Выпускаемые НИУ ВШЭ автомобили с педальными двигателями пользуются большим спросом, но иногда встречаются люди, которые не могут использовать новый тип автомобиля - их ноги слишком слабые, чтобы крутить педали с достаточной силой. Но студенты нашли решение для этой проблемы, выпустив новый тип двигателя - с ручным приводом. Теперь больше людей могут приобрести автомобили, выпускаемые НИУ ВШЭ. Студенты обратились к вам для доработки информационной системы под новые реалии.

Функциональные требования

Информационная система должна учитывать автомобили с обоими типами двигателей

Автомобили с педальным приводом необходимо продавать покупателям с силой ног больше 5

Автомобили с ручным приводом необходимо продавать покупателям с силой рук больше 5

Требования к реализации

В класс Customer добавить две новые характеристики:

Целое число, определяющее силу ног покупателя

Целое число, определяющее силу рук покупателя

Добавить интерфейс IEngine для описания двигателя:

У двигателя должен быть метод, позволяющий проверить совместимость между двигателем и покупателем

Класс Engine переименовать в PedalEngine и добавить реализацию интерфейса IEngine:

При реализации метода определения совместимости двигателя и покупателя учесть функциональные требования

Добавить реализацию интефейса IEngine для двигателя с ручным приводом:

При реализации метода определения совместимости двигателя и покупателя учесть функциональные требования

Для каждой реализации интерфейса IEngine переопределить метод ToString для получения информации о двигателе:

Метод должен возвращать тип двигателя

Заменить ссылку на Engine внутри класса Car на ссылку на интерфейс IEngine:

Определить конструктор, принимающий экземпляр IEngine и номер автомобиля

Добавить в класс Car метод для определения совместимости автомобиля с покупателем:

Внутри метода использовать соответствующий метод интерфейса IEngine

Добавить generic-интерфейс ICarFactory для создания автомобилей:

У интерфейса должен быть один generic-параметр TParams, предназначенный для параметров двигателя

У интерфейса должен быть метод для создания автомобилей:

Метод должен принимать параметр типа TParams

Метод должен принимать номер выпускаемого автомобиля

Добавить класс PedalEngineParams:

Класс должен иметь свойство для педачи размера педалей

Добавить структуру EmptyEngineParams:

У структуры определить статическое поле DEFAULT, содержащее экемпляр структуры

Реализовать интерфейс ICarFactory для педальных автомобилей:

Класс должен называться PedalCarFactory

При реализации интерфейса в качестве аргумента для generic-параметра использовать класс PedalEngineParams

Реализовать интерфейс ICarFactory для автомобилей с ручным приводом:

Класс должен называться HandCarFactory

При реализации интерфейса в качестве аргумента для generic-параметра использовать структуру EmptyEngineParams

Добавить интерфейс ICarProvider

У интерфейса должен быть метод для поиска подходящего автомобиля, принимающий ссылку на покупателя в качестве параметра

Добавить класс CarService для управления автомобилями:

У класса должна быть коллекция объектов Car для хранения автомобилей - при этом между автомобилями и CarService должно быть отношение композиции

Необходимо реализовать интерфейс ICarProvider для класса CarService:

Метод должен пробегаться по коллекции автомобилей и возвращать первый подходящий автомобиль

При реализации учесть, что каждый автомобиль должен быть выдан ровно 1 раз

У класса должен быть generic-метод для добавления автомобилей:

В качестве generic-параметра должен выступать тип TParams для описания параметров двигателя добавляемого автомобиля

Метод должен принимать параметр типа ICarFactory

Также метод должен принимать параметр типа TParams

В своем теле метод должен вычислять номер выпущенного автомобиля - они не должны повторяться

Добавить интерфейс ICustomersProvider:

Интерфейс должен содержать метод для получения списка покупателей

Добавить класс CustomerStorage

У класса должна быть коллекция покупателей

Класс должен реализовывать интерфейс ICustomersProvider

У класса должен быть метод для добавления покупателей

Удалить класс HseCarFactory

Добавить класс HseCarService:

Добавить ссылки на интерфейсы ICarProvider и ICustomersProvider - проинициализировать их через конструктор класса

Добавить метод SellCars:

Метод должен получить покупателей из ICustomersProvider и пробежаться по списку

Если у какого-то покупателя нет автомобиля - метод должен запрашивать автомобиль из ICarProvider

Если автомобиль удалось получить - метод должен назначать его покупателю

Тестирование

Создать экезмпляр класса CarService

Создать экземпляр класса CustomerStorage

Создать экземпляр класса HseCarService

Создать экземпляр класса PedalCarFactory

Создать экземпляр класса HandCarFactory

Добавить следующих покупателей:

С силой ног 6 и силой рук 4

С силой ног 4 и силой рук 6

С силой ног 6 и силой рук 6

С силой ног 4 и силой рук 4

Добавить автомобили:

2 педальных автомобиля

2 автомобиля с ручным приводом

Вывести на экран информацию о покупателях и их автомобилях

Вызвать метод SellCars

Вывести на экран информацию о покупателях и их автомобилях. Проверить, что результат соответствует следующему:

Одному покупателю вручен педальный автомобиль

Одному покупателю вручен автомобиль с ручным приводом

Одному покупателю вручен любой автомобиль


Один покупатель остался без автомобиля

При этом у всех врученных автомобилей различные номера

Пояснения к реализации

Добавление интерфейса IEngine, объединяющего под собой все возможные двигатели, позволяет реализовать принцип подстановки Лисков. Прием в методе класса CarService 
интерфейса ICarFactory, а также параметров для него позволяет нам реализовать принцип открытости-закрытости. Выделение интерфейсов ICarProvider и ICustomersProvider, содержащих лишь необходимую часть функциональности, позволило нам реализовать принцип разделения интерфейсов. Вынесение управления автомобилями и покупателями из HseCarService позволило нам реализовать принципы единственной ответственности и инверсии зависимостей.
